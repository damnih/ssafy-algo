# 1부터 N까지의 자연수를 이진 탐색 트리에 저장
# 이진탐색트리는 어떠한 경우에도 저장된 값이 "왼쪽 서브트리의 루트 < 현재노드 < 오른쪽서브트리의 루트" 규칙 만족
# 추가나 삭제가 없는 경우엔 완전이진트리가 되도록 만들면 효율적인 이진탐색트리를 만들 수 있음
#
# 1
# 23
# 4567
# 89101112131415

# 웅 ~! 그냥 강의 다시 보자!

# 중위탐색
#
# 부모는 i//2
#
# 현재 노드가 i라고 할때
#
# 부모는 i//2
#
# 자식은 i*2랑 i*2+1임
# 그치 이건 항상 그렇지,,
#
# 이진트리에 자동으로 저장이 된거여

def jung_order(T):
    if T:
        jung_order(left[T])
        print(T)
        jung_order(right[T])

# 중위 탐색의 로직? 순서? 방법은 알았어 그렇다면
# 완전 이진 트리의 노드 번호는 정해져있잖아?
#
# 1부터 N까지의 자연수를 이진 탐색 트리에 저장하려고 함
# 한마디로 자동 정렬이 되게 만들자는 거지
#
# 나 . 내 본인. 이 있을 때.
# 나의 왼자식 오자식 둘은
# 왼자식은 나보다작고 오자식은 나보다 커야해
# 즉
# arr[2 * i] < arr[i] < arr[2 * i + 1]

# 어떤 증가하는 자연수 하나에 대해..
# 그러면 일단 그머냐 1부터 넣으면 돼
# 1을 루트에 넣어주겠지?
# 그다음 2를 넣을 건데,
# 얘를 루트에 넣는다 치고, 얘에 맞는 그 위치를 찾아가주면 되는거임
# 이걸,, 넣을 때마다 반복해,,
# 그니깐,,
# i는 인덱스 위치잖아?
# 얘를 계속 소환하면서,, 찾아주는거임!!!
#
# 근데 이렇게되면 배열 하나에서 위치하게 되는거 아닌가?
num = 1
i = 0
#
# 완전이진트리
#
# 자료를 삽입할 때 걍 리스트의 맨 마지막에 넣어준다 생각하면 됨!!!!
# 그니깐 그냥,, append 써주면 되겠는데?!

binary = [0] # 그니깐 걍 인덱스 0은 버려줄거라 이렇게 0으로 시작하는 거야

binary.append(num)
now_ind = binary.index(num)
parent_ind = now_ind // 2

부모와 나를 비교해
만약 내가 부모보다 작다면?
binary[parent_ind] > binary
