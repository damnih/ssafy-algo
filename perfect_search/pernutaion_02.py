
# 2개를 뽑을 예정

# cnt = 재귀호출마다 누적되어서 전달되어야 하는 값
# 뽑은 카드들을 저장
path = []
used = [False] * 7 # 1~6 숫자 사용 여부를 기록
# 왜 7개죠? 숫자는 6개인데??
# -> 그냥 0번 인덱스 버린거임!
# 그냥 0번 인덱스를 낭비하자! (편의를 위해)
# 고작 이거 메모리 하나로 문제가 안풀리면 애초에 문제 설계 잘못한거래 ㅋㅋ

def recur(cnt):
    # 카드를 2개 뽑으면 종료
    if cnt == 3:
        # 종료 시에 해야할 로직들을 작성
        print(*path)
        return # 그냥 이렇게 리턴만 적어도 알아서,, 리턴값이 나옴 재귀함수 그자체를 반환하니깐 ㅇㅇ
    # # 1. 1개의 카드를 뽑는다
    # # 2. 다음 재귀함수를 호출한다 (뽑은 카드가 1개 추가되었다)

    # 같은 방식을 반복문으로 들어간다면
    # 만약 카드가 1~6까지 있다면,,
    for num in range(1, 7):
        if num in path:
            continue
            # 근데 유의
            # in이라는 키워드는 하나하나 다 봄 그래서 한번 볼 때마다 시간 복잡도가 O(len(path))만큼 계속계속 올라감
            # in 이라는 함수는 전체검색이라 시간이 오래 걸림
            # 이를 해결하기 위해 used 만들어봤음
        if used[num] is True:
            continue
        used[num] = True
        path.append(num)
        recur(cnt + 1)
        path.pop()
        # 끝까지 갔다가 돌아올 때 다시 false로 바꿔줘야 함
        used[num] = False

# 돌아왔을 때 뽑아줘야

# 제일 처음 호출할 때 시점이므로
# 초기값을 전달하면서 시작
recur(0)





