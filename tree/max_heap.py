# 죄대힙(099개의 값 저장가능한)

def enq(n):
    global last     # 마지막 정점
    last += 1
    heap[last] = n  # 마지막 정점에 n 저장

    c = last    # 부모의 키값과 비교하기 위해
    p = c // 2  # 부모 정점 번호 계산
    # 부모가 있고, 부모 < 자식 (최대힙 조건 위반)
    while p :


heap = [0] * 100
last = 0

enq(2)
enq(5)
enq(7)
enq(3)
enq(4)
enq(6)


# 라스트가 0인 상태
#
# 2를 넣으면 라스트가 1이 되는 거지
#
# 이제 5를 넣어줘 2번이 라스트가 되겠지?
# 거기에 5를 추가
# 근데 최대힙이잖아?
# 자리를 옮겨줘
# 5가 1번에가고 2가 2번에 감
#
# 우선순위 큐와 같게 enq란 표현을 쓴거임
#
# 이제 7을 넣으면
# 3번이 생성되고 7이 3번에 들어감
# 이제 그 7을 부모 요소와 크기비교함
# 7이 5보다 크잖아? 자리바꿔
# 1번에 7 2번에 2 3번에 5
#
# 이제 3을 넣으면
# 4번이 생성되고 3이 4번에 들어감
# 이제 그 3을 부모 요소와 크기비교함
# 3이 2보다 크잖아? 자리바꿔
# 이제 그 3을 또 부모 요소와 크기비교해
# 3이 7보다 ,, 작네? 자리유지

def deq():                  # 루트 백업
    global last             # 삭제할 노드의 키를 루트에 복사
    tmp = heap[1]           # 마지막 노드 삭제
    heap[1] = heap[last]    # 루트에 옮긴 값을 자식과 비교
    last -= 1               # 마지막 노드 삭제
    p = 1                   # 루트에 옮긴 값을 자식과 비교
    c = p * 2               # 왼쪽 자식 # 자식이 있다면 무조건 왼쪽에 있으니깐 일단 왼쪽 고르고 봐
    while c <= last:        # 자식이 하나라도 있으면,,
        if c + 1 <= last and heap[c] < heap[c + 1]: # 오른쪽 자식도 있고, 오른쪽 자식이 더 크다면,,
            c += 1 # 비교할 대상(자식)을 오른쪽 자식으로 정함
        # 자식이 더 크다면 어케한다그랫음? 교환!!!
        if heap[p] < heap[c]:
            heap[p], heap[c] = heap[c], heap[p]
            p = c # 자식을 새로운 붐로
            c = p * 2 # 왼쪽 자식 번호를 계산
        else:
            break
    return tmp



