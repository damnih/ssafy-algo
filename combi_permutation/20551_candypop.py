# 이런 문제는 일단 카운트를 세서 반환하는 문제인 거임
# 그러니깐 먹을 사탕의 수를 세주면 됨

# 문제를 보면,, A<B 가 될 때까지 A의 사탕을 먹어야하고
# B<C 가 될 때까지 B의 사탕을 먹어야함 

# 이 조건을 만족시킬 수 없다면 -1을 출력해야 함
# 어떤 상황에서 조건 만족이 안되는지를 생각해보면,, 
# 모든 상자가 비어있지 않기를 바라니깐,, 
# C상자가 2개 이하거나 B상자가 1이하이면 A상자를 커버할 수 없으니 조건 성립 불가능함 
# if C <= 2 or B <= 1: 

# 고로 이런 상황일 때 -1을 출력하도록 하면 될 거 같음

# import sys
# sys.stdin = ("20551_sample_input.txt", "r")


def eat_count(A, B, C):
    candy_count = 0

    if C <= 2 or B <= 1: 
        return -1 

    # 먹어야 하는 최소의 사탕이므로, 걍 일단 작아지는 순간까지만 먹으면 됨
    # 일단 B와 C의 개수를 비교하고 만약 B가 더 작다면 걍 냅두고, 크다면 먹어주면 됨 
    # B는 C와의 개수차이 +1 만큼만 먹으면 됨 
    # 아니 걍 B = C-1 이 될때까지 먹으면 됨 ㅇㅇ 
    # 먹을 만큼의 갯수 = B - (C - 1) 

    if B >= C: 
        candy_count += B - C + 1

    # A와 B와의 비교에서도 동일하게 들어가는데, 차이가 있다면 바뀐 B값에 대해서 생각을 해줘야하는거임 
    # 그러니깐 이게 순차적으로 진행되는 코드니깐, 
    # 여기에 B값이 변했음을 써줘야하는거임 

    B = C - 1
    # 근데 이렇게 바뀐 B값이 1이나 0일 수가 있을까? 이미 저 위에서 치고 나와서 ㄱㅊ을거같긴함
    # C의 값 조건에 따라 결정되는거라 ㅇㅇ 

    if A >= B:
        candy_count += A - B + 1

    return candy_count



T = int(input())

for tc in range(1, T+1):
    A, B, C = map(int, input().split())
    ans = eat_count(A, B, C)
    print(f"#{tc} {ans}")