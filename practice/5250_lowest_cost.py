# 상하좌우 칸이 나타나는 인접 지역 = 간선 정보 대신에 델타 탐색을 하라는 얘기
# 한 칸 이동시 연료 += 1
# 그리고 그 칸 이동할 때마다 연료 += 높이 차
#
# 시작점은 무조건 (0,0)
# 도착점은 무조건 (N-1, N-1)
#
# 갔던 곳 다시 가면 안되니깐 방문처리 해줘야겠고,
# 상하좌우 델타탐색하면서 조건은 높이 고저차일테고,
#
# 이걸 그냥 그리디하게 그냥 무조건 높이차가 가장 낮은 곳으로만 가도 되는건가?
# 경로 자체가 짧으면 그것도 이득이잖아
#
# 일단 짜보고 물어보자 ㅜㅜ

'''
3
3
0 2 1
0 1 1
1 1 1
5
0 0 0 0 0
0 1 2 3 0
0 2 3 4 0
0 3 4 5 0
0 0 0 0 0
5
0 1 1 1 0
1 1 0 1 0
0 1 0 1 0
1 0 0 1 1
1 1 1 1 1

'''

T = int(input())
for tc in range(1, T+1):

N = int(input())

height = [list(map(int, input().split())) for _ in range(N)]



# 아냐 이건 무조건 시작점이 있어
# 그러니깐
start = (0, 0, 0)

di = [-1, 1, 0, 0]
dj = [0, 0, -1, 1]

now_i, now_j = pq.pop()

for dir in range(4):
    new_i = now_i + di[dir]
    new_j = now_j + dj[dir]
    # 벽 검사
    if 0 <= new_i < N and 0 <= new_j < N:
        # 이제 그 넥스트 좌표에 대해서 그 값을 저장해줘야함
        dh = height[now_i][now_j] - height[new_i][new_j]


