# import sys
# sys.stdin = open("1486_input.txt", "r")
#

'''
B = 선반 높이
N = 점원들 명수
H = 높이들

높이가 B인 탑 중에서 가장 작은 녀석 골라내야 함

그니깐 이건 쉽게 생각하면 전체 부분집합을 구해서 그 합을 구한 뒤
B이상 중 최소를 고르는 식으로 하면 되는,, 거네?

근데 부분집합을 전부 구하는 건 시간이 오래 걸리잖아
백트래킹을 해가며 경우의 수를 잘라가는 건 어때?
재귀다..

일단 재귀를 하려면 중요한 게 뭐야? 종료조건, 과 바뀌는 값이 무엇인지, 이다

종료조건은,, 키들의 합이 B보다 커지는 경우일 거고,
바뀌는 값은,, 키들의 합?
make_tower(height):
이러면 되는 걸까?

키를 오름차순 정렬해서 넘는걸 생각해볼까 했는데
b가 12인데 3 5 6 12 키로 주어지는 경우도 있을 수 있잖아
그러니깐 굳이 오름차순 정렬해서 앞에서부터 더해줄 필요는 없는 거 같아

그냥 이 키를 넣던가 안넣던가
둘 중 하나의 경우만 있는 거,, 지?


아 이제 좀 알 거 같다..
그니깐 재귀를 돌릴 때 중요한 건
그 재귀의 깊이와, 가짓수인 거임
이거는 재귀의 깊이가 어떻게 되겠어?
몇 명까지 쌓느냐일테니깐 점원의 수가 재귀의 깊이가 되겠지?
가짓수는 내가 처음 생각했던 것처럼 그 점원을 넣느냐 안 넣느냐 일테고 ㅇㅇ
'''

# 한마디로 재귀함수를 만들 때 쓸모있는건
# 그럼 이 문제에서는 계속 커지는건 키니깐 키가 계속 들어가줘야겠고
# 각 레벨에서 넣냐 안넣냐로 가짓수가 갈리는거니깐
# 그 각 레벨을 나타낼 인자도 있으면 좋겠다 !!!

# height = [299, 239, 116, 128]
height = [1,4,6,8]
N, B = 4, 416
sum = float('inf')

def human_tower(level, total_height):
    # 함수가 호출될때마다 초기화되면 안되니깐 함수 밖에 변수를 두고 이걸 바꾸게 변동시키자
    global sum
    # # 이 모든 걸 겪고도 B에 도달하지 못했다면,
    # if total_height < B and level == N: # 애 조건이 틀렸대
    #     return -1
    # elif total_height >= B and level == N:
    #     return
    # 이렇게 하면 안돼서,, 기계뇌의 도움을 받음
    # 그냥 level도달조건만 달성하면 리턴하게 하자
    if level == N:
        return total_height if total_height >= B else -1 # 한줄에서 리턴의 종류를 경우를 나눠서 표현해줄 수 있음!!!
        # 그냥 이 level == N이 중단조건이 될수도 있음 이건 무조건 도달하는 거니깐 ㅇㅇ
        # return
    # 중단 조건은 일단 이 total_height이 B에 도달했을 때임
    if total_height >= B: # 얘도 조건이 틀렸대
        # 여기서는 그니깐 이후에 있을 애들 중 미니멈값을 리턴하는거지...?
        sum = min(sum, total_height)
        # 저 위의 리턴은 중단조건이고 그냥 함수의 리턴도 있어야함
        return
    # 이 재귀함수는 각 레벨에서 점원을 넣느냐, 안넣느냐 두 개 뿐이지?
    # 그니깐 이 레벨에서 키를 더해주고 말고
    human_tower(level + 1, total_height + height[level])
    human_tower(level + 1, total_height)

    # 근데 이러면 그냥 커질때만 리턴이니깐,, 가장 작은 min을 만들고 싶을 때는 어떻게 해야할까?

ans = human_tower(0,0)

print(sum)
# print(ans)



